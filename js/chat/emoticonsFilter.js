/**
 * Simple Emoticon filter that converts plain-text emoticons to <DIV> with css class names based on the emoticon
 *
 * @param megaChat
 * @returns {EmoticonsFilter}
 * @constructor
 */
var EmoticonsFilter = function(megaChat) {
    var self = this;

    self.emoticonsMap = {
        ':)': 'smile',
        ':(': 'sad',
        '(rofl)': 'rofl',
        ':d': 'bigsmile',
        ':p': 'tongueout'

    };

    //RegExpEscape

    var escapedRegExps = [];
    $.each(self.emoticonsMap, function(k, v) {
        escapedRegExps.push(
            RegExpEscape(k)
        );
    });

    var regExpStr = "(^|\\W)(" + escapedRegExps.join("|") + ")(?=(\\s|$))";

    self.emoticonsRegExp = new RegExp(regExpStr, "gi");

    megaChat.bind("onReceiveMessage", function(e, eventData) {
        self.processMessage(e, eventData);
    });

    return this;
};

EmoticonsFilter.prototype.processMessage = function(e, eventData) {
    var self = this;

    // use the HTML version of the message if such exists (the HTML version should be generated by hooks/filters on the
    // client side.
    var message = eventData.messageHtml ? eventData.messageHtml : eventData.getContents();

    if(!message) {
        return; // ignore, maybe its a system message (or composing/paused composing notification)
    }

    message = message.replace(self.emoticonsRegExp, function(match) {
        var cssClassName = self.emoticonsMap[$.trim(match.toLowerCase())];

        if(cssClassName) {
            return '<span class="fm-chat-emoticon fm-chat-emoticon-' + cssClassName + '" title="' + match + '">' + match + '</span>'
        } else {
            return match;
        }
    });

    eventData.messageHtml = message;
};