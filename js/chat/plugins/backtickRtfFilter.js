/**
 * Backtick specific Rich text formatting filter
 *
 * @param megaChat
 * @returns {BacktickRtfFilter}
 * @constructor
 */
var BacktickRtfFilter = function(megaChat) {
    "use strict";
    var self = this;

    self.regexps = {};
    self.regexps['(^|\\\\s)?\\s?`{3}(\\n?)([^(?!```).]{1,})`{3}'] = [
        'gim',
        '$1<pre class="rtf-multi">$3</pre>',
        '$1 $3'
    ];

    self.regexps['(^|\\s)`{1}([^`\\n]{1,})`{1}'] = ['gi', '$1<pre class="rtf-single">$2</pre>', '$1 $2'];
    self.escaped = {};
    self.index = 0;

    megaChat.rebind("onPreBeforeRenderMessage.btrtf", function(e, eventData) {
        self.escapeAndProcessMessage(e, eventData, ['messageHtml', 'textContents'], 'messageHtml');
    });
    megaChat.rebind("onPostBeforeRenderMessage.btrtf", function(e, eventData) {
        self.unescapeAndProcessMessage(e, eventData, ['messageHtml', 'textContents'], 'messageHtml');
    });

    megaChat.rebind("onPreBeforeSendMessage.btrtf", function(e, eventData) {
        self.escapeAndProcessMessage(e, eventData, ['message', 'messageHtml', 'textContents'], 'message');
    });
    megaChat.rebind("onPostBeforeSendMessage.btrtf", function(e, eventData) {
        self.unescapeAndProcessMessage(e, eventData, ['message', 'messageHtml', 'textContents'], 'message');
    });

    return this;
};

BacktickRtfFilter.ESCAPE_TEMPLATE = "%%BTRTE%$NUM%%";
BacktickRtfFilter.ESCAPE_SEARCH = "%%BTRTE%";
BacktickRtfFilter.UNESCAPE_REGEXP = "%%BTRTE%(\\d+)%%";

BacktickRtfFilter.prototype.processStripRtfFromMessage = function(msg) {
    "use strict";
    var self = this;
    Object.keys(self.regexps).forEach(function(regexp) {
        var replacement = self.regexps[regexp];
        msg = msg.replace(new RegExp(regexp, replacement[0]), replacement[2]);
    });
    return msg;
};


BacktickRtfFilter.prototype.escapeAndProcessMessage = function(e, eventData, props, mainProp) {
    "use strict";
    var self = this;

    if (eventData instanceof Message) {
        // in case of incoming data is a before send msg
        eventData = {
            'message': eventData
        };
    }

    if (eventData.message.decrypted === false) {
        return;
    }

    // use the HTML version of the message if such exists (the HTML version should be generated by hooks/filters on the
    // client side.
    var textContents;
    if (eventData.message.textContents) {
        textContents = eventData.message.textContents;
    } else {
        return; // not yet decrypted.
    }


    props.forEach(function(prop) {
        var messageContents = eventData.message[prop] ? eventData.message[prop] : textContents;

        if (prop === "messageHtml" && !eventData.message[prop]) {
            messageContents = htmlentities(messageContents);
        }

        if (!messageContents) {
            return; // ignore, maybe its a system message (or composing/paused composing notification)
        }

        messageContents = messageContents ? $.trim(messageContents) : "";

        /*jshint -W049 */
        if (prop === "messageHtml") {
            messageContents = messageContents.replace(/\<br\/\>/gi, '\n');
        }
        /*jshint +W049 */
        Object.keys(self.regexps).forEach(function(regexp, type) {
            var replacement = self.regexps[regexp];
            messageContents = messageContents.replace(new RegExp(regexp, replacement[0]), function(match) {
                var id = self.index++;
                self.escaped[id] = [type, match.replace(new RegExp(regexp, replacement[0]), replacement[1]), match];
                return BacktickRtfFilter.ESCAPE_TEMPLATE.replace("$NUM", id);
            });
        });

        if (prop === "messageHtml") {
            messageContents = messageContents.replace(/\n/gi, "<br/>");
        }
        eventData.message[prop] = messageContents;
    });


    return eventData.message[mainProp];
};

BacktickRtfFilter.prototype.unescapeAndProcessMessage = function(e, eventData, props, mainProp) {
    "use strict";
    var self = this;

    if (eventData instanceof Message) {
        // in case of incoming data is a before send msg
        eventData = {
            'message': eventData
        };
    }

    if (eventData.message.decrypted === false) {
        return;
    }

    // use the HTML version of the message if such exists (the HTML version should be generated by hooks/filters on the
    // client side.
    var textContents;
    if (eventData.message.textContents) {
        textContents = eventData.message.textContents;
    } else {
        return; // not yet decrypted.
    }



    props.forEach(function(prop) {
        var messageContents = eventData.message[prop] ? eventData.message[prop] : textContents;

        if (!messageContents) {
            return; // ignore, maybe its a system message (or composing/paused composing notification)
        }

        messageContents = messageContents ? $.trim(messageContents) : "";

        /*jshint -W049 */
        if (prop === "messageHtml") {
            messageContents = messageContents.replace(/\<br\/\>/gi, '\n');
        }
        /*jshint +W049 */

        messageContents = messageContents.replace(
            new RegExp(BacktickRtfFilter.UNESCAPE_REGEXP, "gi"),
            function(match, id) {
                var escaped = self.escaped[id];
                var result = match;
                if (escaped) {
                    if (prop === "messageHtml") {
                        result = escaped[1];
                    }
                    else {
                        result = escaped[2];
                    }
                    delete self.escaped[id];
                }

                return result;
            });

        if (prop === "messageHtml") {
            messageContents = messageContents.replace(/\n/gi, "<br/>");
        }

        eventData.message[prop] = messageContents;
    });


    if (eventData.message[mainProp].indexOf(BacktickRtfFilter.ESCAPE_SEARCH) > -1) {
        // recurse to ensure ALL escaped stuff are unescaped (specially if nested with some super tricky strings)
        return self.unescapeAndProcessMessage(e, eventData, props, mainProp);
    }

    return eventData.message[mainProp];
};
